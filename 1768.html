<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Per-Channel Color Removal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90%;
            width: 700px; /* Wider for slider */
        }
        canvas {
            border-radius: 8px;
            background-color: #000;
            max-width: 100%;
            height: auto;
            display: block;
        }
        input[type="file"] {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #4a5568; /* Gray border */
            background-color: #4a5568;
            color: #e2e8f0;
            cursor: pointer;
        }
        input[type="file"]::-webkit-file-upload-button {
            background-color: #4299e1;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #3182ce;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* Override default slider styles */
            height: 8px;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .slider-label {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 5px;
            text-align: center;
        }
        .message-box {
            background-color: #2a4365; /* Darker blue for message box */
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-5">
    <div class="container bg-gray-800 rounded-xl shadow-lg p-6">
        <h1 class="text-3xl font-bold mb-4 text-blue-400">Image Per-Channel Color Removal</h1>

        <input type="file" id="imageUpload" accept="image/*" class="mb-4">

        <div class="w-full mb-4">
            <label for="levelSlider" class="slider-label block mb-2">Available Levels: <span id="currentLevels">768</span></label>
            <input type="range" id="levelSlider" min="1" max="768" value="768" class="w-full">
        </div>

        <canvas id="canvas" class="rounded-lg border-2 border-gray-700 w-full"></canvas>

        <div id="messageBox" class="message-box mt-4 bg-gray-700 text-gray-200 rounded-lg p-3 w-full">
            Please upload an image to begin.
        </div>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const levelSlider = document.getElementById('levelSlider');
        const currentLevelsSpan = document.getElementById('currentLevels');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const messageBox = document.getElementById('messageBox');

        let originalImageData = null; // Stores the original pixel data of the uploaded image
        let masterLevelList = []; // Stores all 768 (channel, level) pairs, shuffled once
        let availableRedLevels = new Set();
        let availableGreenLevels = new Set();
        let availableBlueLevels = new Set();
        let removedRedMap = new Map();
        let removedGreenMap = new Map();
        let removedBlueMap = new Map();

        // --- Utility Functions ---

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        /**
         * Finds the closest available intensity level in a given set to a target level.
         * @param {number} targetLevel - The intensity level to find a close match for (0-255).
         * @param {Set<number>} availableLevelsSet - The set of currently available intensity levels.
         * @returns {number} The closest available intensity level.
         */
        function findClosestLevel(targetLevel, availableLevelsSet) {
            if (availableLevelsSet.size === 0) {
                return 0; // Return 0 (black) if no levels are available
            }

            let closestLevel = 0;
            let minDifference = Infinity;

            // Convert Set to Array for easier iteration and sorting if needed, though direct iteration is fine.
            const levelsArray = Array.from(availableLevelsSet);

            for (const level of levelsArray) {
                const diff = Math.abs(targetLevel - level);
                if (diff < minDifference) {
                    minDifference = diff;
                    closestLevel = level;
                }
            }
            return closestLevel;
        }

        // --- Palette Management ---

        /**
         * Initializes the master list of all 768 (channel, level) pairs and shuffles it.
         * This ensures consistent random removal based on slider position.
         */
        function initializeMasterLevelList() {
            masterLevelList = [];
            for (let i = 0; i <= 255; i++) {
                masterLevelList.push({ channel: 'r', level: i });
                masterLevelList.push({ channel: 'g', level: i });
                masterLevelList.push({ channel: 'b', level: i });
            }
            shuffleArray(masterLevelList); // Shuffle once at the start
        }

        /**
         * Updates the available levels and removed maps based on the slider's value.
         * @param {number} sliderValue - The desired number of total available levels (1 to 768).
         */
        function updatePaletteBasedOnSlider(sliderValue) {
            // Clear previous states
            availableRedLevels.clear();
            availableGreenLevels.clear();
            availableBlueLevels.clear();
            removedRedMap.clear();
            removedGreenMap.clear();
            removedBlueMap.clear();

            const levelsToKeepCount = sliderValue;
            const levelsToRemoveCount = 768 - sliderValue;

            // First pass: Populate available levels and mark removed levels
            for (let i = 0; i < masterLevelList.length; i++) {
                const { channel, level } = masterLevelList[i];

                if (i < levelsToRemoveCount) {
                    // This level is marked for removal
                    if (channel === 'r') removedRedMap.set(level, null); // Placeholder null for now
                    else if (channel === 'g') removedGreenMap.set(level, null);
                    else if (channel === 'b') removedBlueMap.set(level, null);
                } else {
                    // This level is to be kept
                    if (channel === 'r') availableRedLevels.add(level);
                    else if (channel === 'g') availableGreenLevels.add(level);
                    else if (channel === 'b') availableBlueLevels.add(level);
                }
            }

            // Second pass: Find closest available levels for removed ones
            // Iterate over the maps and find the closest available level within their own channel
            removedRedMap.forEach((_, removedLevel) => {
                const closest = findClosestLevel(removedLevel, availableRedLevels);
                removedRedMap.set(removedLevel, closest);
            });
            removedGreenMap.forEach((_, removedLevel) => {
                const closest = findClosestLevel(removedLevel, availableGreenLevels);
                removedGreenMap.set(removedLevel, closest);
            });
            removedBlueMap.forEach((_, removedLevel) => {
                const closest = findClosestLevel(removedLevel, availableBlueLevels);
                removedBlueMap.set(removedLevel, closest);
            });

            messageBox.textContent = `Processing with ${levelsToKeepCount} total available levels.`;
            processImage(); // Re-process the image with the new palette
        }

        // --- Image Processing ---

        /**
         * Processes the loaded image data based on the current available levels and removed maps.
         */
        function processImage() {
            if (!originalImageData) {
                return; // No image loaded yet
            }

            // Create a new ImageData object from the original data to modify
            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            const data = imageData.data;

            // Iterate over each pixel
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // Apply remapping for Red channel
                if (removedRedMap.has(r)) {
                    r = removedRedMap.get(r);
                } else {
                    // If not explicitly removed, ensure it's quantized to an available level
                    r = findClosestLevel(r, availableRedLevels);
                }

                // Apply remapping for Green channel
                if (removedGreenMap.has(g)) {
                    g = removedGreenMap.get(g);
                } else {
                    g = findClosestLevel(g, availableGreenLevels);
                }

                // Apply remapping for Blue channel
                if (removedBlueMap.has(b)) {
                    b = removedBlueMap.get(b);
                } else {
                    b = findClosestLevel(b, availableBlueLevels);
                }

                // Update the pixel data
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }

            // Put the modified image data back onto the canvas
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Event Listeners ---

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            messageBox.textContent = "Loading image...";
            const reader = new FileReader();

            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Set canvas dimensions to match image
                    canvas.width = img.width;
                    canvas.height = img.height;

                    // Draw the original image to get its pixel data
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Reset slider to max and update palette
                    levelSlider.value = 768;
                    currentLevelsSpan.textContent = 768;
                    updatePaletteBasedOnSlider(768); // Process with full levels initially

                    messageBox.textContent = "Image loaded. Adjust the slider to remove color levels.";
                    levelSlider.disabled = false; // Enable slider once image is loaded
                };
                img.onerror = () => {
                    messageBox.textContent = "Could not load image. Please try another file.";
                    originalImageData = null;
                    levelSlider.disabled = true;
                };
                img.src = e.target.result;
            };

            reader.onerror = () => {
                messageBox.textContent = "Error reading file.";
                originalImageData = null;
                levelSlider.disabled = true;
            };

            reader.readAsDataURL(file);
        });

        levelSlider.addEventListener('input', () => {
            const sliderValue = parseInt(levelSlider.value);
            currentLevelsSpan.textContent = sliderValue;
            updatePaletteBasedOnSlider(sliderValue);
        });

        // --- Initial Setup ---
        window.onload = () => {
            initializeMasterLevelList();
            levelSlider.disabled = true; // Disable slider until an image is loaded
            messageBox.textContent = "Please upload an image to begin.";
        };

    </script>
</body>
</html>
